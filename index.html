<html>
    <head>

        <style>
        body {
    background:black;
    
}

#container{
  background: #CCCCCC;
    position: absolute;
    top:0;
    left:0;
}

#world {
    z-index: 1;
    position: absolute;
    top:0;
    left:0;
}


#critter {
    z-index: 2;
    position: absolute;
    top:0;
    left:0;
}

#stats {
    z-index: 4;
    position: absolute;
    top:0px;
}

#cPanel {
    z-index: 3;
    position: absolute;
    top:0px;
    right: 0%;
    height:100%;
    background:rgba(0,0,0,0.55);
    width:200px;
    color: #AAAAAA;
}

#cPanel #entityPanel {
    border-top: thin solid #777777;
    margin: 15px;
    padding: 5px 0;
}

#cPanel h1, #cPanel h2 {
    text-align:center;
}

#cPanel h2 {
    font-size: 20px;
    text-align: center;
}
        </style>

        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"></script>
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.1/jquery.min.js"></script>
        <script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/stats.js/r11/Stats.js"></script>

        <script>
// ----- PERLIN ---- //
// This is a port of Ken Perlin's Java code. The
// original Java code is at http://cs.nyu.edu/%7Eperlin/noise/.
// Note that in this version, a number from 0 to 1 is returned.
PerlinNoise = new function() {

this.noise = function(x, y, z) {

   var p = new Array(512)
   var permutation = [ 151,160,137,91,90,15,
   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
   ];
   for (var i=0; i < 256 ; i++) 
 p[256+i] = p[i] = permutation[i]; 

      var X = Math.floor(x) & 255,                  // FIND UNIT CUBE THAT
          Y = Math.floor(y) & 255,                  // CONTAINS POINT.
          Z = Math.floor(z) & 255;
      x -= Math.floor(x);                                // FIND RELATIVE X,Y,Z
      y -= Math.floor(y);                                // OF POINT IN CUBE.
      z -= Math.floor(z);
      var    u = fade(x),                                // COMPUTE FADE CURVES
             v = fade(y),                                // FOR EACH OF X,Y,Z.
             w = fade(z);
      var A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z,      // HASH COORDINATES OF
          B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      // THE 8 CUBE CORNERS,

      return scale(lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  // AND ADD
                                     grad(p[BA  ], x-1, y  , z   )), // BLENDED
                             lerp(u, grad(p[AB  ], x  , y-1, z   ),  // RESULTS
                                     grad(p[BB  ], x-1, y-1, z   ))),// FROM  8
                     lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  // CORNERS
                                     grad(p[BA+1], x-1, y  , z-1 )), // OF CUBE
                             lerp(u, grad(p[AB+1], x  , y-1, z-1 ),
                                     grad(p[BB+1], x-1, y-1, z-1 )))));
   }
   function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
   function lerp( t, a, b) { return a + t * (b - a); }
   function grad(hash, x, y, z) {
      var h = hash & 15;                      // CONVERT LO 4 BITS OF HASH CODE
      var u = h<8 ? x : y,                 // INTO 12 GRADIENT DIRECTIONS.
             v = h<4 ? y : h==12||h==14 ? x : z;
      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);
   } 
   function scale(n) { return (1 + n)/2; }
}


// ----- Utils.js ----- //
_.mixin({
    setPixel: function (imageData, x, y, r, g, b, a) {
        var index = ((y * imageData.width) + x) * 4;
        imageData.data[index+0] = r;
        imageData.data[index+1] = g;
        imageData.data[index+2] = b;
        imageData.data[index+3] = a;
        }, 
        getPixel: function(imageData, x, y) { 
            var index = ((y * imageData.width) + x) * 4;
            
            return new Color(
                imageData.data[index+0],
                imageData.data[index+1],
                imageData.data[index+2],
                imageData.data[index+3]
                );
        },
        randomBetween: function(min, max) {
            return Math.floor((Math.random() * ((max + 1) - min)) + min);
        }
});


////////////////////////////////////////////////////
// Application Constants //////////////////////////
//////////////////////////////////////////////////

const WORLD_WIDTH = 250;
const WORLD_HEIGHT =250;
const PERLIN_SCALE = 4;
const PERLIN_SEED_R = 1;
const PERLIN_SEED_G = 2;
const PERLIN_SEED_B = 3;
const TOTAL_CRITTERS = 700;

////////////////////////////////////////////////////
// Base Entity ////////////////////////////////////
//////////////////////////////////////////////////
var Color = function(r, g, b, a){
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
};

_.extend(Color.prototype, {
    equals: function(color) {
        return this.r === color.r
            && this.g === color.g
            && this.b === color.b
            && this.a === color.a;
    }
});

var Entity = function() {};

_.extend(Entity.prototype, {
    setPosition: function(x, y) {
        
        // save where we were
        this.lastX = this.x;
        this.lastY = this.y;
        
        // set the position
        this.x = x;
        this.y = y;
        
        // hey you get back here you asshole
        if(this.y > WORLD_HEIGHT) this.y = 0;
        if(this.x > WORLD_WIDTH) this.x = 0;
        if(this.x < 0) this.x = WORLD_WIDTH;
        if(this.y < 0) this.y = WORLD_HEIGHT;
    },
    
    setColor: function(c) {
        this.r = (c>> 16) & 255;
        this.g = (c>> 8) & 255;
        this.b = c & 255;
        this.a = 30;
    },
    
    update: function(critterLayer, worldLayer) {
    },
    
    draw: function(critterLayer, worldLayer) {
        _.setPixel(imageData, this.lastX, this.lastY, this.r, this.g, this.b, 0);
        _.setPixel(imageData, this.x, this.y, this.r, this.g, this.b, this.a);
    }
});

////////////////////////////////////////////////////
// Locomotive Entity ////////////////////////////////////
//////////////////////////////////////////////////
var LocomotiveEntitiy = function() {
    this.velocity = {x:0, y:0};
    this.directions = [-1,0,1];
};

_.extend(LocomotiveEntitiy.prototype, Entity.prototype, {
    
    
    update: function(critterLayer, worldLayer) {
        this.setPosition(this.x + this.velocity.x, this.y + this.velocity.y);
        var color = _.getPixel(critterLayer, this.x, this.y);
        if(color.a > 80) {
            var rnd = Math.random() < .5;
            if(rnd) this.velocity.x = this.directions[Math.floor(Math.random() * this.directions.length)];
            else this.velocity.y = this.directions[Math.floor(Math.random() * this.directions.length)];
        }
    },
    
    draw: function(critterLayer, worldLayer) {
        var color = _.getPixel(critterLayer, this.x, this.y);
        var newA = (this.a + color.a) % 255;
        _.setPixel(critterLayer, this.lastX, this.lastY, this.r, this.g, this.b, newA - 1);
        _.setPixel(critterLayer, this.x, this.y, this.r, this.g, this.b, newA);
    }
});

////////////////////////////////////////////////////
// Color Eater ////////////////////////////////////
//////////////////////////////////////////////////
var ColorEater = function(targetColor) {
    this.targetColor = targetColor;
    this.nowColor;
    this.eatCurrentLocation = false;
    this.velocity = {x:1, y:1};
};

_.extend(ColorEater.prototype, Entity.prototype, {
    
    setRandomDirection: function () {
        do
        {
            this.velocity.x = _.randomBetween(-1, 1);
            this.velocity.y = _.randomBetween(-1, 1);
        }
        while(this.velocity.x === 0 && this.velocity.y === 0)
        
    },
    
    update: function(critterLayer, worldLayer) {
        this.setPosition(this.x + this.velocity.x, this.y + this.velocity.y);
        
        this.nowColor = _.getPixel(worldLayer, this.x, this.y);
        
        if(this.targetColor.r < this.nowColor.r) {
            this.eatCurrentLocation = true;
            this.setRandomDirection();
        }
    },
    
    draw: function(critterLayer, worldLayer) {
        
        _.setPixel(critterLayer, this.lastX, this.lastY, this.r, this.g, this.b, 0);
        _.setPixel(critterLayer, this.x, this.y, this.r, this.g, this.b, this.a);
        
        if(this.eatCurrentLocation === true) {
            _.setPixel(worldLayer, this.x, this.y, this.nowColor.r, this.nowColor.g, this.nowColor.b, this.nowColor.a - 10);
            this.eatCurrentLocation = false;
        }
    }
});

// ----- Main.js ----- //
$(document).ready(function() {
    
    var circle;
    var stats;
    
    var worldLayer;
    var critterLayer;
    
    var critters = [];
    
    var setup = function() {
        var $container = $('#container');
        
        this.canvas = document.getElementById('world');
        this.worldContext = this.canvas.getContext('2d');
        
        this.canvas = document.getElementById('critter');
        this.critterContext = this.canvas.getContext('2d');
        
        //fill the browser
        $('#world').css({width:window.innerWidth, height:window.innerHeight})
            .attr({width:WORLD_WIDTH, height:WORLD_HEIGHT});
        $('#critter').css({width:window.innerWidth, height:window.innerHeight})
            .attr({width:WORLD_WIDTH, height:WORLD_HEIGHT});
        
        this.width = this.canvas.width;
        this.height = this.canvas.height;
        
        var colors = [0x381939,0xAD3269,0xF0BB77,0xE88D1A, 0x315E59]
        for(var i = 0; i < TOTAL_CRITTERS; i++) {
            var critter = new LocomotiveEntitiy();
            critter.setColor(colors[Math.floor(Math.random() * colors.length)]);
            critter.setPosition(Math.round(Math.random() * WORLD_WIDTH), Math.round(Math.random() * WORLD_HEIGHT));
            critters.push(critter);
        }
        
        //Spawn Color Eaters
        for(var i = 0; i < TOTAL_CRITTERS/2; i++) {
            var critter = new ColorEater(new Color(150, 0, 0, 255));
            critter.setColor(0x48FFFFFF);
            critter.setPosition(Math.round(Math.random() * WORLD_WIDTH), Math.round(Math.random() * WORLD_HEIGHT));
            critters.push(critter);
        }
        
        //maka da stats happen
        stats = new Stats();
        stats.domElement.id = "stats";
        $container.append(stats.domElement);
        
        //Two Bitmaps - NOT added to stage. Modify these, draw routine will composite
        //Access via backgroundLayer.data[0]
        worldLayer = this.worldContext.createImageData(WORLD_WIDTH, WORLD_HEIGHT);
        critterLayer = this.critterContext.createImageData(WORLD_WIDTH, WORLD_HEIGHT);

        //setup controls
        var $cPanel = $("#cPanel");
        $cPanel.hide();
        var $body = $("body");
        $body.mouseover(function() {
            $cPanel.stop(true).hide().fadeIn();
        });

        $body.mouseout(function() {
            $cPanel.stop(true).show().fadeOut();
        });

        drawWorld();
    };
    
    var drawWorld = function(seedShift) {
        seedShift = seedShift || 0;
        
        for (var row=0; row < WORLD_WIDTH; row++)
        {
            for (var column=0; column < WORLD_HEIGHT; column++)
            {
                var pvalr = PerlinNoise.noise((row/WORLD_WIDTH) * PERLIN_SCALE, (column/WORLD_HEIGHT) * PERLIN_SCALE, PERLIN_SEED_R + seedShift);
                var pvalg = PerlinNoise.noise((row/WORLD_WIDTH) * PERLIN_SCALE, (column/WORLD_HEIGHT) * PERLIN_SCALE, PERLIN_SEED_G + seedShift);
                var pvalb = PerlinNoise.noise((row/WORLD_WIDTH) * PERLIN_SCALE, (column/WORLD_HEIGHT) * PERLIN_SCALE, PERLIN_SEED_B + seedShift);
                
                _.setPixel(worldLayer, row, column, 255*pvalr, 255*pvalg, 255*pvalb, 255);
            }
        }
    }
    
    var draw = function(time) {
        
        stats.update();
        
        // clear the canvas
        //this.worldContext.clearRect(0, 0, this.width, this.height);
        this.critterContext.clearRect(0, 0, this.width, this.height);

                var critterLength = critters.length;
              for(var i = 0; i < critterLength; i++) {
                    var critter = critters[i];
                    critter.update(critterLayer, worldLayer);
                    critter.draw(critterLayer, worldLayer);
                }
            
        //Draw all Background Pixels, then the Actor Pixels
        this.worldContext.putImageData(worldLayer, 0, 0);
        this.critterContext.putImageData(critterLayer, 0, 0);
    };

    setup();
    
    // ----- UPDATE LOOP ----- //
    (function updateFrame(time){
            draw(time);
            window.requestAnimationFrame(updateFrame);
    })();

});


// ----- POLY FILLS ---- //
// -- requestAnimationFrame
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller
// fixes from Paul Irish and Tino Zijdel
(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
                                   || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
 
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); },
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
 
    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());
        </script>

    </head>
    <body>
            
            <div id="container">
                
            </div>
            
            <div id="cPanel">
                <h1>Controls</h1>
                <div id="entityPanel">
                    <div id="entity">
                        <h2>Color Eater</h2>
                    </div>
                </div>
            </div>
            
            <canvas id="world" width="40" height="40">
                Uber Sad, no world layer.
            </canvas>
            <canvas id="critter" width="40" height="40">
                Uber Sad, no critter layer.
            </canvas>
    </body>
</html>